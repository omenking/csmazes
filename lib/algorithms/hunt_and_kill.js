// Generated by CoffeeScript 2.7.0
/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
*/
Maze.Algorithms.HuntAndKill = (function() {
  class HuntAndKill extends Maze.Algorithm {
    constructor(maze, options) {
      super(args);
      this.state = 0;
    }

    isCurrent(x, y) {
      var ref;
      return ((ref = this.x) != null ? ref : x) === x && this.y === y;
    }

    isWalking() {
      return this.state === 1;
    }

    isHunting() {
      return this.state === 2;
    }

    callbackRow(y) {
      var i, ref, results, x;
      results = [];
      for (x = i = 0, ref = this.maze.width; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
        results.push(this.updateAt(x, y));
      }
      return results;
    }

    startStep() {
      this.x = this.rand.nextInteger(this.maze.width);
      this.y = this.rand.nextInteger(this.maze.height);
      this.maze.carve(this.x, this.y, this.IN);
      this.updateAt(this.x, this.y);
      return this.state = 1;
    }

    walkStep() {
      var direction, i, len, nx, ny, ref, x, y;
      ref = this.rand.randomDirections();
      for (i = 0, len = ref.length; i < len; i++) {
        direction = ref[i];
        nx = this.x + Maze.Direction.dx[direction];
        ny = this.y + Maze.Direction.dy[direction];
        if (this.maze.isValid(nx, ny)) {
          if (this.maze.isBlank(nx, ny)) {
            [x, y, this.x, this.y] = [this.x, this.y, nx, ny];
            this.maze.carve(x, y, direction);
            this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
            this.updateAt(x, y);
            this.updateAt(nx, ny);
            return;
          } else if (this.canWeave(direction, nx, ny)) {
            this.performWeave(direction, this.x, this.y, (x, y) => {
              return [x, y, this.x, this.y] = [this.x, this.y, x, y];
            });
            return;
          }
        }
      }
      [x, y] = [this.x, this.y];
      delete this.x;
      delete this.y;
      this.updateAt(x, y); // remove highlight from current cell
      this.eventAt(x, y);
      this.y = 0;
      this.state = 2;
      return this.callbackRow(0); // highlight the first row
    }

    huntStep() {
      var direction, i, neighbors, nx, ny, ref, x;
      for (x = i = 0, ref = this.maze.width; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
        if (this.maze.isBlank(x, this.y)) {
          neighbors = [];
          if (this.y > 0 && !this.maze.isBlank(x, this.y - 1)) {
            neighbors.push(Maze.Direction.N);
          }
          if (x > 0 && !this.maze.isBlank(x - 1, this.y)) {
            neighbors.push(Maze.Direction.W);
          }
          if (this.y + 1 < this.maze.height && !this.maze.isBlank(x, this.y + 1)) {
            neighbors.push(Maze.Direction.S);
          }
          if (x + 1 < this.maze.width && !this.maze.isBlank(x + 1, this.y)) {
            neighbors.push(Maze.Direction.E);
          }
          direction = this.rand.randomElement(neighbors);
          if (direction) {
            this.x = x;
            nx = this.x + Maze.Direction.dx[direction];
            ny = this.y + Maze.Direction.dy[direction];
            this.maze.carve(this.x, this.y, direction);
            this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
            this.state = 1;
            // update passages for neighbor
            this.updateAt(nx, ny);
            // clear highlight in row (because we set @x) and update passages at @x, @y
            this.callbackRow(this.y);
            this.eventAt(nx, ny);
            return;
          }
        }
      }
      this.y++;
      this.callbackRow(this.y - 1); // clear highlight for prior row
      if (this.y >= this.maze.height) {
        this.state = 3;
        delete this.x;
        return delete this.y;
      } else {
        return this.callbackRow(this.y); // highlight next row
      }
    }

    step() {
      switch (this.state) {
        case 0:
          this.startStep();
          break;
        case 1:
          this.walkStep();
          break;
        case 2:
          this.huntStep();
      }
      return this.state !== 3;
    }

  };

  HuntAndKill.prototype.IN = 0x1000;

  return HuntAndKill;

}).call(this);
