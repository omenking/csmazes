// Generated by CoffeeScript 2.7.0
/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
*/
// This hybrid algorithm was described to me by Robin Houston. It
// begins with the Aldous-Broder algorithm, to fill out the grid,
// and then switches to Wilson's after the grid is about 1/3
// populated.

// This gives you better performance than either algorithm by itself,
// but while intuitively it would seem this preserves the properties
// of the original algorithms, it is not yet certain whether this still
// creates a uniform spanning tree or not.
Maze.Algorithms.Houston = class Houston extends Maze.Algorithm {
  constructor(maze, options) {
    super(args);
    this.options = options;
    this.threshold = 2 * this.maze.width * this.maze.height / 3;
  }

  isCurrent(x, y) {
    return this.worker.isCurrent(x, y);
  }

  isVisited(x, y) {
    return this.worker.isVisited(x, y);
  }

  step() {
    var wilsons, x, y;
    if (this.worker == null) {
      this.worker = new Maze.Algorithms.AldousBroder(this.maze, this.options);
      this.worker.onUpdate(this.updateCallback);
      this.worker.onEvent(this.eventCallback);
    }
    if (this.worker.remaining < this.threshold) {
      // kind of messy, need to tell the callback listener that
      // current cell is no longer current, since the algorithm
      // is changing.
      [x, y] = [this.worker.x, this.worker.y];
      delete this.worker.x;
      delete this.worker.y;
      this.updateAt(x, y);
      this.eventAt(x, y);
      // switch to wilsons and redefine the step method so it
      // no longer watches the threshold.
      wilsons = new Maze.Algorithms.Wilson(this.maze, this.options);
      wilsons.onUpdate(this.updateCallback);
      wilsons.onEvent(this.eventCallback);
      wilsons.state = 1;
      wilsons.remaining = this.worker.remaining;
      this.worker = wilsons;
      this.step = function() {
        return this.worker.step();
      };
    }
    return this.worker.step();
  }

};
