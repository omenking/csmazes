// Generated by CoffeeScript 2.7.0
/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
*/
Maze.Algorithms.Eller = (function() {
  class Eller extends Maze.Algorithm {
    constructor(maze, options) {
      super(args);
      this.state = new Maze.Algorithms.Eller.State(this.maze.width).populate();
      this.row = 0;
      this.pending = true;
      this.initializeRow();
    }

    initializeRow() {
      this.column = 0;
      return this.mode = this.HORIZONTAL;
    }

    isFinal() {
      return this.row + 1 === this.maze.height;
    }

    isIn(x, y) {
      return this.maze.isValid(x, y) && this.maze.isSet(x, y, this.IN);
    }

    isCurrent(x, y) {
      return this.column === x && this.row === y;
    }

    horizontalStep() {
      var oldColumn;
      if (!this.state.isSame(this.column, this.column + 1) && (this.isFinal() || this.rand.nextBoolean())) {
        this.state.merge(this.column, this.column + 1);
        this.maze.carve(this.column, this.row, Maze.Direction.E);
        this.updateAt(this.column, this.row);
        this.maze.carve(this.column + 1, this.row, Maze.Direction.W);
        this.updateAt(this.column + 1, this.row);
      } else if (this.maze.isBlank(this.column, this.row)) {
        this.maze.carve(this.column, this.row, this.IN);
        this.updateAt(this.column, this.row);
      }
      this.column += 1;
      if (this.column > 0) {
        this.updateAt(this.column - 1, this.row);
      }
      this.updateAt(this.column, this.row);
      if (this.column + 1 >= this.maze.width) {
        if (this.maze.isBlank(this.column, this.row)) {
          this.maze.carve(this.column, this.row, this.IN);
          this.updateAt(this.column, this.row);
        }
        if (this.isFinal()) {
          this.pending = false;
          [oldColumn, this.column] = [this.column, null];
          return this.updateAt(oldColumn, this.row); // clear the "current" status
        } else {
          this.mode = this.VERTICAL;
          this.next_state = this.state.next();
          this.verticals = this.computeVerticals();
          return this.eventAt(0, this.row);
        }
      }
    }

    computeVerticals() {
      var verts;
      verts = [];
      this.state.foreach((id, set) => {
        var cellsToConnect, countFromThisSet;
        countFromThisSet = 1 + this.rand.nextInteger(set.length - 1);
        cellsToConnect = this.rand.randomizeList(set).slice(0, countFromThisSet);
        return verts = verts.concat(cellsToConnect);
      });
      return verts.sort(function(a, b) {
        return a - b;
      });
    }

    verticalStep() {
      var oldColumn;
      if (this.verticals.length === 0) {
        this.state = this.next_state.populate();
        this.row += 1;
        oldColumn = this.column;
        this.initializeRow();
        this.eventAt(0, this.row);
        this.updateAt(oldColumn, this.row - 1);
        return this.updateAt(this.column, this.row);
      } else {
        [oldColumn, this.column] = [this.column, this.verticals.pop()];
        this.updateAt(oldColumn, this.row);
        this.next_state.add(this.column, this.state.setFor(this.column));
        this.maze.carve(this.column, this.row, Maze.Direction.S);
        this.updateAt(this.column, this.row);
        this.maze.carve(this.column, this.row + 1, Maze.Direction.N);
        return this.updateAt(this.column, this.row + 1);
      }
    }

    step() {
      switch (this.mode) {
        case this.HORIZONTAL:
          this.horizontalStep();
          break;
        case this.VERTICAL:
          this.verticalStep();
      }
      return this.pending;
    }

  };

  Eller.prototype.IN = 0x1000;

  Eller.prototype.HORIZONTAL = 0;

  Eller.prototype.VERTICAL = 1;

  return Eller;

}).call(this);

Maze.Algorithms.Eller.State = class State {
  constructor(width, counter) {
    this.width = width;
    this.counter = counter;
    if (this.counter == null) {
      this.counter = 0;
    }
    this.sets = {};
    this.cells = [];
  }

  next() {
    return new Maze.Algorithms.Eller.State(this.width, this.counter);
  }

  populate() {
    var base, cell, set;
    cell = 0;
    while (cell < this.width) {
      if (!this.cells[cell]) {
        set = (this.counter += 1);
        ((base = this.sets)[set] != null ? base[set] : base[set] = []).push(cell);
        this.cells[cell] = set;
      }
      cell += 1;
    }
    return this;
  }

  merge(sink, target) {
    var cell, i, len, ref, sink_set, target_set;
    sink_set = this.cells[sink];
    target_set = this.cells[target];
    this.sets[sink_set] = this.sets[sink_set].concat(this.sets[target_set]);
    ref = this.sets[target_set];
    for (i = 0, len = ref.length; i < len; i++) {
      cell = ref[i];
      this.cells[cell] = sink_set;
    }
    return delete this.sets[target_set];
  }

  isSame(a, b) {
    return this.cells[a] === this.cells[b];
  }

  add(cell, set) {
    var base;
    this.cells[cell] = set;
    ((base = this.sets)[set] != null ? base[set] : base[set] = []).push(cell);
    return this;
  }

  setFor(cell) {
    return this.cells[cell];
  }

  foreach(fn) {
    var id, ref, results, set;
    ref = this.sets;
    results = [];
    for (id in ref) {
      set = ref[id];
      results.push(fn(id, set));
    }
    return results;
  }

};
