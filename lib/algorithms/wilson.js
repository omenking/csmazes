// Generated by CoffeeScript 2.7.0
/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
*/
Maze.Algorithms.Wilson = (function() {
  class Wilson extends Maze.Algorithm {
    constructor(maze, options) {
      super(args);
      this.state = 0;
      this.remaining = this.maze.width * this.maze.height;
      this.visits = {};
    }

    isCurrent(x, y) {
      return this.x === x && this.y === y;
    }

    isVisited(x, y) {
      return this.visits[`${x}:${y}`] != null;
    }

    addVisit(x, y, dir) {
      return this.visits[`${x}:${y}`] = dir != null ? dir : 0;
    }

    exitTaken(x, y) {
      return this.visits[`${x}:${y}`];
    }

    startStep() {
      var x, y;
      x = this.rand.nextInteger(this.maze.width);
      y = this.rand.nextInteger(this.maze.height);
      this.maze.carve(x, y, this.IN);
      this.updateAt(x, y);
      this.remaining--;
      return this.state = 1;
    }

    startWalkStep() {
      var results;
      this.visits = {};
      results = [];
      while (true) {
        this.x = this.rand.nextInteger(this.maze.width);
        this.y = this.rand.nextInteger(this.maze.height);
        if (this.maze.isBlank(this.x, this.y)) {
          this.eventAt(this.x, this.y);
          this.state = 2;
          this.start = {
            x: this.x,
            y: this.y
          };
          this.addVisit(this.x, this.y);
          this.updateAt(this.x, this.y);
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    walkStep() {
      var direction, i, len, nx, ny, ref, results, x, y;
      ref = this.rand.randomDirections();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        direction = ref[i];
        nx = this.x + Maze.Direction.dx[direction];
        ny = this.y + Maze.Direction.dy[direction];
        if (this.maze.isValid(nx, ny)) {
          [x, y, this.x, this.y] = [this.x, this.y, nx, ny];
          if (this.isVisited(nx, ny)) {
            this.eraseLoopFrom(nx, ny);
          } else {
            this.addVisit(x, y, direction);
          }
          this.updateAt(x, y);
          this.updateAt(nx, ny);
          if (!this.maze.isBlank(nx, ny)) {
            this.x = this.start.x;
            this.y = this.start.y;
            this.state = 3;
            this.eventAt(this.x, this.y);
          }
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    resetVisits() {
      var dir, key, ref, results, x, y;
      ref = this.visits;
      results = [];
      for (key in ref) {
        dir = ref[key];
        [x, y] = key.split(":");
        delete this.visits[key];
        results.push(this.updateAt(x, y));
      }
      return results;
    }

    runStep() {
      var dir, nx, ny, x, y;
      if (this.remaining > 0) {
        dir = this.exitTaken(this.x, this.y);
        nx = this.x + Maze.Direction.dx[dir];
        ny = this.y + Maze.Direction.dy[dir];
        if (!this.maze.isBlank(nx, ny)) {
          this.resetVisits();
          this.state = 1;
        }
        this.maze.carve(this.x, this.y, dir);
        this.maze.carve(nx, ny, Maze.Direction.opposite[dir]);
        [x, y, this.x, this.y] = [this.x, this.y, nx, ny];
        if (this.state === 1) {
          delete this.x;
          delete this.y;
        }
        this.updateAt(x, y);
        this.updateAt(nx, ny);
        this.remaining--;
      }
      return this.remaining > 0;
    }

    step() {
      if (this.remaining > 0) {
        switch (this.state) {
          case 0:
            this.startStep();
            break;
          case 1:
            this.startWalkStep();
            break;
          case 2:
            this.walkStep();
            break;
          case 3:
            this.runStep();
        }
      }
      return this.remaining > 0;
    }

    eraseLoopFrom(x, y) {
      var dir, key, nx, ny, results;
      results = [];
      while (true) {
        dir = this.exitTaken(x, y);
        if (!dir) {
          break;
        }
        nx = x + Maze.Direction.dx[dir];
        ny = y + Maze.Direction.dy[dir];
        key = `${x}:${y}`;
        delete this.visits[key];
        this.updateAt(x, y);
        results.push([x, y] = [nx, ny]);
      }
      return results;
    }

  };

  Wilson.prototype.IN = 0x1000;

  return Wilson;

}).call(this);
