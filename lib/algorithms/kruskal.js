// Generated by CoffeeScript 2.7.0
/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
*/
Maze.Algorithms.Kruskal = (function() {
  class Kruskal extends Maze.Algorithm {
    constructor(maze, options) {
      var i, j, ref, ref1, ref2, ref3, x, y;
      super(args);
      this.sets = [];
      this.edges = [];
      for (y = i = 0, ref = this.maze.height; (0 <= ref ? i < ref : i > ref); y = 0 <= ref ? ++i : --i) {
        this.sets.push([]);
        for (x = j = 0, ref1 = this.maze.width; (0 <= ref1 ? j < ref1 : j > ref1); x = 0 <= ref1 ? ++j : --j) {
          this.sets[y].push(new Maze.Algorithms.Kruskal.Tree());
          if (y > 0) {
            this.edges.push({
              x: x,
              y: y,
              direction: Maze.Direction.N
            });
          }
          if (x > 0) {
            this.edges.push({
              x: x,
              y: y,
              direction: Maze.Direction.W
            });
          }
        }
      }
      this.rand.randomizeList(this.edges);
      this.weaveMode = (ref2 = options.weaveMode) != null ? ref2 : "onePhase";
      if (typeof this.weaveMode === "function") {
        this.weaveMode = this.weaveMode();
      }
      this.weaveDensity = (ref3 = options.weaveDensity) != null ? ref3 : 80;
      if (typeof this.weaveDensity === "function") {
        this.weaveDensity = this.weaveDensity();
      }
      this.state = (this.maze.isWeave != null) && this.weaveMode === "twoPhase" ? this.WEAVE : this.JOIN;
    }

    connect(x1, y1, x2, y2, direction) {
      this.sets[y1][x1].connect(this.sets[y2][x2]);
      this.maze.carve(x1, y1, direction);
      this.updateAt(x1, y1);
      this.maze.carve(x2, y2, Maze.Direction.opposite[direction]);
      return this.updateAt(x2, y2);
    }

    weaveStep() {
      var edge, ex, ey, i, len, newEdges, nx, ny, ref, results, safe, sx, sy, wx, wy;
      if (this.x == null) {
        this.y = 1;
        this.x = 1;
      }
      results = [];
      while (this.state === this.WEAVE) {
        if (this.maze.isBlank(this.x, this.y) && this.rand.nextInteger(100) < this.weaveDensity) {
          [nx, ny] = [this.x, this.y - 1];
          [wx, wy] = [this.x - 1, this.y];
          [ex, ey] = [this.x + 1, this.y];
          [sx, sy] = [this.x, this.y + 1];
          safe = !this.sets[ny][nx].isConnectedTo(this.sets[sy][sx]) && !this.sets[wy][wx].isConnectedTo(this.sets[ey][ex]);
          if (safe) {
            this.sets[ny][nx].connect(this.sets[sy][sx]);
            this.sets[wy][wx].connect(this.sets[ey][ex]);
            if (this.rand.nextBoolean()) {
              this.maze.carve(this.x, this.y, Maze.Direction.E | Maze.Direction.W | Maze.Direction.U);
            } else {
              this.maze.carve(this.x, this.y, Maze.Direction.N | Maze.Direction.S | Maze.Direction.U);
            }
            this.maze.carve(nx, ny, Maze.Direction.S);
            this.maze.carve(wx, wy, Maze.Direction.E);
            this.maze.carve(ex, ey, Maze.Direction.W);
            this.maze.carve(sx, sy, Maze.Direction.N);
            this.updateAt(this.x, this.y);
            this.updateAt(nx, ny);
            this.updateAt(wx, wy);
            this.updateAt(ex, ey);
            this.updateAt(sx, sy);
            newEdges = [];
            ref = this.edges;
            for (i = 0, len = ref.length; i < len; i++) {
              edge = ref[i];
              if ((edge.x === this.x && edge.y === this.y) || (edge.x === ex && edge.y === ey && edge.direction === Maze.Direction.W) || (edge.x === sx && edge.y === sy && edge.direction === Maze.Direction.N)) {
                continue;
              }
              newEdges.push(edge);
            }
            this.edges = newEdges;
            break;
          }
        }
        this.x++;
        if (this.x >= this.maze.width - 1) {
          this.x = 1;
          this.y++;
          if (this.y >= this.maze.height - 1) {
            this.state = this.JOIN;
            results.push(this.eventAt(this.x, this.y));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    joinStep() {
      var edge, edge2, i, index, nx, nx2, ny, ny2, ref, results, set1, set2, set3;
      results = [];
      while (this.edges.length > 0) {
        edge = this.edges.pop();
        nx = edge.x + Maze.Direction.dx[edge.direction];
        ny = edge.y + Maze.Direction.dy[edge.direction];
        set1 = this.sets[edge.y][edge.x];
        set2 = this.sets[ny][nx];
        if ((this.maze.isWeave != null) && this.weaveMode === "onePhase" && this.maze.isPerpendicular(nx, ny, edge.direction)) {
          nx2 = nx + Maze.Direction.dx[edge.direction];
          ny2 = ny + Maze.Direction.dy[edge.direction];
          set3 = null;
          for (index = i = 0, ref = this.edges.length; (0 <= ref ? i < ref : i > ref); index = 0 <= ref ? ++i : --i) {
            edge2 = this.edges[index];
            if (edge2.x === nx && edge2.y === ny && edge2.direction === edge.direction) {
              this.edges.splice(index, 1);
              set3 = this.sets[ny2][nx2];
              break;
            }
          }
          if (set3 && !set1.isConnectedTo(set3)) {
            this.connect(edge.x, edge.y, nx2, ny2, edge.direction);
            this.performThruWeave(nx, ny);
            this.updateAt(nx, ny);
            break;
          } else if (!set1.isConnectedTo(set2)) {
            this.connect(edge.x, edge.y, nx, ny, edge.direction);
            break;
          } else {
            results.push(void 0);
          }
        } else if (!set1.isConnectedTo(set2)) {
          this.connect(edge.x, edge.y, nx, ny, edge.direction);
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    step() {
      switch (this.state) {
        case this.WEAVE:
          this.weaveStep();
          break;
        case this.JOIN:
          this.joinStep();
      }
      return this.edges.length > 0;
    }

  };

  Kruskal.prototype.WEAVE = 1;

  Kruskal.prototype.JOIN = 2;

  return Kruskal;

}).call(this);

Maze.Algorithms.Kruskal.Tree = class Tree {
  constructor() {
    this.up = null;
  }

  root() {
    if (this.up) {
      return this.up.root();
    } else {
      return this;
    }
  }

  isConnectedTo(tree) {
    return this.root() === tree.root();
  }

  connect(tree) {
    return tree.root().up = this;
  }

};
